// QA Studio - Test Reporting Platform Schema
// Inspired by Allure TestOps and TestRail

generator client {
  provider = "prisma-client-js"
  // output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USERS & TEAMS
// ============================================

model User {
  id        String   @id // Clerk user ID
  email     String   @unique
  firstName String?
  lastName  String?
  imageUrl  String?
  role      UserRole @default(TESTER)

  // Team membership
  teamId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  team             Team?        @relation(fields: [teamId], references: [id], onDelete: SetNull)
  createdProjects  Project[]    @relation("ProjectCreator")
  createdTestCases TestCase[]   @relation("TestCaseCreator")
  createdTestRuns  TestRun[]    @relation("TestRunCreator")
  executedResults  TestResult[] @relation("TestResultExecutor")
  apiKeys          ApiKey[]

  @@index([email])
  @@index([teamId])
  @@index([role])
}

model ApiKey {
  id         String    @id @default(cuid())
  name       String // User-friendly name like "CI/CD Pipeline"
  key        String    @unique // The actual API key (hashed)
  prefix     String // First 8 chars for display (e.g., "qas_1234...")
  userId     String
  lastUsedAt DateTime?
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([key])
  @@index([prefix])
}

model Team {
  id             String   @id @default(cuid())
  name           String
  description    String?
  overSeatLimit  Boolean  @default(false) // True when team has more members than paid seats
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  members      User[]
  projects     Project[]
  subscription Subscription?
  integrations Integration[]
  invitations  TeamInvitation[]

  @@index([name])
  @@index([overSeatLimit])
}

model Subscription {
  id                   String             @id @default(cuid())
  teamId               String             @unique
  stripeCustomerId     String             @unique
  stripeSubscriptionId String?            @unique
  stripePriceId        String?
  status               SubscriptionStatus @default(INCOMPLETE)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  seats                Int                @default(1)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  // Relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([teamId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
}

enum SubscriptionStatus {
  ACTIVE // Paid and active
  PAST_DUE // Payment failed
  CANCELED // Subscription canceled
  INCOMPLETE // Initial payment pending
  INCOMPLETE_EXPIRED // Initial payment failed
  UNPAID // Payment failed, subscription ended
}

enum UserRole {
  ADMIN // Full system access
  MANAGER // Can manage projects and teams
  TESTER // Can create and execute tests
  VIEWER // Read-only access
}

// ============================================
// PROJECTS & ORGANIZATION
// ============================================

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  key         String   @unique // Short identifier like "PROJ"
  createdBy   String // Clerk user ID
  teamId      String? // Optional team ownership
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator      User          @relation("ProjectCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  team         Team?         @relation(fields: [teamId], references: [id], onDelete: SetNull)
  testSuites   TestSuite[]
  testCases    TestCase[]
  testRuns     TestRun[]
  milestones   Milestone[]
  environments Environment[]
  jiraIssues   JiraIssue[]

  @@index([createdBy])
  @@index([teamId])
  @@index([updatedAt]) // For sorting by recently updated
  @@index([createdAt]) // For sorting by recently created
}

model Milestone {
  id          String          @id @default(cuid())
  name        String
  description String?
  dueDate     DateTime?
  status      MilestoneStatus @default(ACTIVE)
  projectId   String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  project  Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  testRuns TestRun[]

  @@index([projectId])
  @@index([status])
  @@index([dueDate]) // For finding upcoming/overdue milestones
  @@index([projectId, status]) // Composite for filtering active milestones by project
}

enum MilestoneStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
}

model Environment {
  id          String   @id @default(cuid())
  name        String // e.g., "Production", "Staging", "QA"
  description String?
  projectId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project  Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  testRuns TestRun[]

  @@unique([projectId, name])
  @@index([projectId])
}

// ============================================
// TEST SUITES & CASES
// ============================================

model TestSuite {
  id          String   @id @default(cuid())
  name        String
  description String?
  projectId   String
  parentId    String? // For nested suites
  order       Int      @default(0) // For drag-and-drop ordering
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parent    TestSuite?  @relation("SuiteHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  TestSuite[] @relation("SuiteHierarchy")
  testCases TestCase[]

  @@index([projectId])
  @@index([parentId])
  @@index([projectId, order]) // Composite for ordered suite listing
}

model TestCase {
  id               String           @id @default(cuid())
  title            String
  description      String?
  preconditions    String? // Setup requirements
  steps            Json? // Array of test steps
  expectedResult   String?
  priority         Priority         @default(MEDIUM)
  type             TestType         @default(FUNCTIONAL)
  automationStatus AutomationStatus @default(NOT_AUTOMATED)
  tags             String[] // For categorization
  projectId        String
  suiteId          String?
  createdBy        String // Clerk user ID
  order            Int              @default(0) // For drag-and-drop ordering
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  creator     User         @relation("TestCaseCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  suite       TestSuite?   @relation(fields: [suiteId], references: [id], onDelete: SetNull)
  results     TestResult[]
  attachments Attachment[]

  @@index([projectId])
  @@index([suiteId])
  @@index([priority])
  @@index([type])
  @@index([createdBy])
  @@index([order])
  @@index([automationStatus]) // For filtering automated vs manual tests
  @@index([projectId, priority]) // Composite for filtering high-priority tests
  @@index([projectId, type]) // Composite for filtering by test type
  @@index([suiteId, order]) // Composite for ordered test case listing within suite
}

enum Priority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum TestType {
  FUNCTIONAL
  REGRESSION
  SMOKE
  INTEGRATION
  PERFORMANCE
  SECURITY
  UI
  API
  UNIT
  E2E
}

enum AutomationStatus {
  AUTOMATED
  NOT_AUTOMATED
  CANDIDATE
}

// ============================================
// TEST RUNS & RESULTS
// ============================================

model TestRun {
  id            String    @id @default(cuid())
  name          String
  description   String?
  projectId     String
  milestoneId   String?
  environmentId String?
  status        RunStatus @default(PLANNED)
  createdBy     String // Clerk user ID
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // AI-generated content
  aiSummary            String? // AI-generated summary of the test run
  aiPatternAnalysis    String? // AI-generated failure pattern analysis
  aiSummaryGeneratedAt DateTime? // When the AI summary was generated

  creator     User         @relation("TestRunCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  milestone   Milestone?   @relation(fields: [milestoneId], references: [id], onDelete: SetNull)
  environment Environment? @relation(fields: [environmentId], references: [id], onDelete: SetNull)
  results     TestResult[]

  @@index([projectId])
  @@index([milestoneId])
  @@index([environmentId])
  @@index([status])
  @@index([createdBy])
  @@index([createdAt]) // For sorting by recently created
  @@index([completedAt]) // For finding recently completed runs
  @@index([projectId, status]) // Composite for filtering active runs by project
  @@index([projectId, createdAt]) // Composite for recent runs by project
}

enum RunStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  ABORTED
}

model TestResult {
  id           String     @id @default(cuid())
  testCaseId   String
  testRunId    String
  status       TestStatus
  comment      String? // Tester notes
  duration     Int? // Duration in milliseconds
  stackTrace   String? // For failures
  errorMessage String? // For failures
  executedBy   String // Clerk user ID
  executedAt   DateTime   @default(now())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // AI-generated content
  aiDiagnosis            String? // AI-generated diagnosis for failed tests
  aiDiagnosisGeneratedAt DateTime? // When the AI diagnosis was generated

  // Additional test metadata (from Playwright/test runners)
  fullTitle     String? // Full hierarchical test path (e.g., "Suite > Subsuite > Test")
  errorSnippet  String? // Error context snippet
  errorLocation Json? // {file, line, column} where error occurred
  startTime     DateTime? // When test started
  endTime       DateTime? // When test ended
  retry         Int @default(0) // Retry attempt number (0 for first attempt)
  projectName   String? @default("default") // Project/browser name (e.g., "chromium")
  metadata      Json? // Additional metadata {tags, location, etc.}
  consoleOutput Json? // {stdout, stderr} console output

  executor    User             @relation("TestResultExecutor", fields: [executedBy], references: [id], onDelete: Cascade)
  testCase    TestCase         @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  testRun     TestRun          @relation(fields: [testRunId], references: [id], onDelete: Cascade)
  attachments Attachment[]
  steps       TestStepResult[]
  jiraIssues  JiraIssue[]

  @@unique([testCaseId, testRunId, retry]) // Prevent duplicate results for same test case, run, and retry attempt
  @@index([testCaseId])
  @@index([testRunId])
  @@index([status])
  @@index([executedAt])
  @@index([executedBy])
  @@index([testRunId, status]) // Composite for filtering results by status within a run
  @@index([testCaseId, executedAt]) // Composite for test case execution history
  @@index([testRunId, executedAt]) // Composite for chronological results within a run
}

enum TestStatus {
  PASSED
  FAILED
  BLOCKED
  SKIPPED
  RETEST
  UNTESTED
}

model TestStepResult {
  id           String     @id @default(cuid())
  testResultId String
  parentStepId String? // For nested steps (hierarchical structure)
  stepNumber   Int // Order within parent
  title        String // Step title
  category     String? // hook, test.step, pw:api, expect, fixture, other
  status       TestStatus
  comment      String?
  duration     Int? // Duration in milliseconds
  startTime    DateTime? // When step started
  error        String? // Error message if step failed
  stackTrace   String? // Stack trace for failures
  location     Json? // {file, line, column} source code location
  createdAt    DateTime   @default(now())

  testResult  TestResult       @relation(fields: [testResultId], references: [id], onDelete: Cascade)
  parentStep  TestStepResult?  @relation("StepHierarchy", fields: [parentStepId], references: [id], onDelete: Cascade)
  childSteps  TestStepResult[] @relation("StepHierarchy")

  // Index strategy:
  // - [testResultId]: Fast lookup of all steps for a test result
  // - [parentStepId]: Fast lookup of child steps in hierarchy
  // - [testResultId, stepNumber]: Ordered retrieval of steps within a test result
  // Note: While [testResultId, stepNumber] can serve testResultId-only queries via leftmost prefix,
  // we keep the dedicated single-column index for optimal performance on the common access pattern
  @@index([testResultId])
  @@index([parentStepId])
  @@index([testResultId, stepNumber])
}

// ============================================
// ATTACHMENTS & MEDIA
// ============================================

model Attachment {
  id           String   @id @default(cuid())
  filename     String
  originalName String
  mimeType     String
  size         Int // Size in bytes
  url          String // Storage location (S3, local, etc.)
  testCaseId   String?
  testResultId String?
  createdAt    DateTime @default(now())

  testCase   TestCase?   @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  testResult TestResult? @relation(fields: [testResultId], references: [id], onDelete: Cascade)

  @@index([testCaseId])
  @@index([testResultId])
  @@index([createdAt]) // For sorting attachments by upload time
  @@index([mimeType]) // For filtering by attachment type (images, videos, etc.)
}

// ============================================
// INTEGRATIONS
// ============================================

model Integration {
  id     String            @id @default(cuid())
  teamId String
  type   IntegrationType
  name   String // User-friendly name like "Engineering Slack"
  status IntegrationStatus @default(ACTIVE)

  // OAuth & Connection Data (encrypted in production)
  accessToken    String? // OAuth access token
  refreshToken   String? // OAuth refresh token
  tokenExpiresAt DateTime?
  webhookUrl     String? // For incoming webhooks
  webhookSecret  String? // For verifying webhook signatures

  // Integration-specific configuration (JSON)
  config Json? // Channel IDs, preferences, etc.

  // Metadata
  installedBy  String // User ID who installed
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  team          Team                      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  notifications IntegrationNotification[]
  jiraIssues    JiraIssue[]

  @@index([teamId])
  @@index([type])
  @@index([status])
  @@index([teamId, status]) // Composite for filtering active integrations by team
  @@index([teamId, type]) // Composite for finding specific integration types
}

enum IntegrationType {
  SLACK
  DISCORD
  TEAMS
  JIRA
  GITHUB
  GITLAB
  WEBHOOK
}

enum IntegrationStatus {
  ACTIVE
  INACTIVE
  ERROR
  EXPIRED
}

model IntegrationNotification {
  id            String             @id @default(cuid())
  integrationId String
  eventType     NotificationEvent
  status        NotificationStatus @default(PENDING)
  payload       Json // Event data to send
  response      Json? // Response from integration
  error         String?
  attempts      Int                @default(0)
  maxAttempts   Int                @default(3)
  nextRetryAt   DateTime?
  sentAt        DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  integration Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  @@index([integrationId])
  @@index([status])
  @@index([eventType])
  @@index([nextRetryAt])
  @@index([createdAt]) // For finding recent notifications
  @@index([integrationId, status]) // Composite for filtering notifications by status
  @@index([status, nextRetryAt]) // Composite for finding pending retries
}

enum NotificationEvent {
  TEST_RUN_STARTED
  TEST_RUN_COMPLETED
  TEST_RUN_FAILED
  TEST_CASE_FAILED
  TEST_CASE_PASSED
  MILESTONE_DUE
  PROJECT_CREATED
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  RETRYING
}

// ============================================
// TEAM INVITATIONS
// ============================================

model TeamInvitation {
  id         String           @id @default(cuid())
  teamId     String
  email      String
  role       UserRole         @default(TESTER)
  status     InvitationStatus @default(PENDING)
  invitedBy  String // User ID who sent the invitation
  token      String           @unique // Unique token for accepting invitation
  expiresAt  DateTime // Invitations expire after 7 days
  acceptedAt DateTime?
  declinedAt DateTime?
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, email]) // One pending invitation per email per team
  @@index([teamId])
  @@index([email])
  @@index([token])
  @@index([status])
  @@index([expiresAt]) // For finding expired invitations
  @@index([teamId, status]) // Composite for filtering invitations by status
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  CANCELED
}

// ============================================
// JIRA INTEGRATION
// ============================================

model JiraIssue {
  id            String  @id @default(cuid())
  jiraIssueKey  String  @unique // e.g., "PROJ-123"
  jiraIssueId   String // Jira's internal ID
  integrationId String // Which Jira integration created this
  testResultId  String? // Link to test result that triggered creation
  projectId     String // QA Studio project

  // Jira issue details (cached for performance)
  summary     String
  description String?
  issueType   String // Bug, Task, Story, etc.
  status      String // Open, In Progress, Done, etc.
  priority    String? // High, Medium, Low, etc.
  assignee    String? // Jira user display name
  reporter    String? // Jira user display name
  labels      String[] // Jira labels

  // Sync metadata
  lastSyncedAt DateTime?
  syncError    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  integration Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  testResult  TestResult? @relation(fields: [testResultId], references: [id], onDelete: SetNull)
  project     Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([integrationId])
  @@index([testResultId])
  @@index([projectId])
  @@index([jiraIssueKey])
  @@index([status])
  @@index([createdAt])
}
